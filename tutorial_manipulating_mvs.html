<!DOCTYPE html>
<html>
	<head>
	<title>How to use the GALua module -- Manipulating multi-vectors</title>
	<link rel="stylesheet" type="text/css" href="http://www.keplerproject.org/doc.css"/>
	</head>
	<body>
	
	<div id="container">
	
	<div id="product">
		<div id="product_logo">
			<a href="http://www.lua.org/"><img alt="GALua" src="lua-logo-ga.png"></a>
		</div><!-- id="product_logo" -->
		<div id="product_name"><big><strong>GALua</strong></big></div>
		<div id="product_description">Geometric Algebra Library for the Lua Programming Language</div>
	
	</div><!-- id="product" -->
	
	<div id="main">
	
	<div id="navigation">
	<!-- How do I include navbar.html??? -->
	</div><!-- id="navigation" -->
	
	<div id="content">
	
	<h1>Manipulating multi-vectors</h1>
	
	<p>
	In this tutorial we cover GALua's overload of the indexing operator ("<code>[]</code>") for multi-vector values.
	We have already seen that if the value used as an index with this operator is a multi-vector
	value, then we just get the inner product.  If, however, you provide an integer index,
	the result is a multi-vector that is the part of the indexed multi-vector being homogeneous
	of the grade that is the intergral index.  An example may make this clearer.
	</p>
	
<pre class="example">
local vecA = e1 + e2
local vecB = e2 + e3
local rotor = vecA * vecB
print( "rotor = " .. tostring( rotor ) )
print( "rotor[0] = " .. tostring( rotor[0] ) )
print( "rotor[1] = " .. tostring( rotor[1] ) )
print( "rotor[2] = " .. tostring( rotor[2] ) )
</pre>

	<p>
	Running this Lua code, we get the following output.
	</p>
<pre class="example">
rotor = 1.00 + e1^e2 + e1^e3 + e2^e3
rotor[0] = 1.00
rotor[1] = 0
rotor[2] = e1^e2 + e1^e3 + e2^e3
</pre>
  
	<p>
	We can also use the indexing operator ("<code>[]</code>") to assign certain grade
	parts of a given multi-vector.
	</p>
	
<pre class="example">
rotor[0] = e2 .. e1
rotor[2] = e2 ^ e1
</pre>

	<p>
	Be aware that if you try to assign a multi-vector homogeneous of the wrong grade,
	you will get a fatal error.
	</p>

<pre class="example">
rotor[2] = vecB    -- Error!
</pre>

	<p>
	Being able to manipulate multi-vectors this way, it also becomes important to realize
	that a multi-vector variable is nothing more than a reference to a multi-vector value.
	Consider the following Lua code.
	</p>
	
<pre class="example">
local multivecA = 5 + e1 + e1^e2
local multivecB = multivecA
multivecB[1] = e2
print( "multivecA = " .. tostring( multivecA ) )
</pre>

	<p>
	This script will print "<code>5 + e2 + e1^e2</code>", not "<code>5 + e1 + e1^e2</code>"
	as one might expect.  What the programmer may have intended to do is the following.
	</p>
		
<pre class="example">
local multivecA = 5 + e1 + e1^e2
local multivecB = multivecA:copy()
multivecB[1] = e2
print( "multivecA = " .. tostring( multivecA ) )
</pre>
	
	<p>
	By utilizing the <code>:copy()</code> meta-method of the multi-vector data-type, we're
	able to return a new copy of the value referenced by the <code>multivecA</code> variable to
	be referenced by the <code>multivecB</code> variable.  This new code now prints
	"<code>5 + e1 + e1^e2</code>" as originally intended.
	</p>
	
	<p><a href="tutorial_cgautil.html">Utilizing the CGA companion module</a></p>
	
	</div><!-- id="content" -->
	
	</div><!-- id="main" -->
	
	<div id="about">
	<p>Copyright (C) 2013, by Spencer T. Parkin</p>
	</div><!-- id="about" -->
	
	</div><!-- id="container" -->
	
	</body>
</html>