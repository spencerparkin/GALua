<!DOCTYPE html>
<html>
	<head>
	<title>How to use the GALua module</title>
	</head>
	<body>
	
	<h1>Defining the geometric algebra</h1>
	
	<p>
	To define a geometric algebra, we give GALua a set of basis vectors and then define the behavior
	of those basis vectors in the inner product.  Such behavior is often referred to as the signature
	of the geometric algebra.
	</p>
	
<pre>
  galua_api.def_basis{ "e1", "e2", "e3" }
  galua_api.def_sig( function( i, j )
    if i == j then
      return 1
    end
    return 0
  end )</pre>
	
	<p>
	The indices given to the <code>def_sig</code> function correspond to the array
	given to the <code>def_basis</code> function.  Note than when GA calculations are
	performed by the module, this function does not get called to determine the result
	of an inner product between two basis vectors.  The function given here is immediately
	evaluated to generate the full inner-product table, which is then kept and use
	internally for use in evaluating subsequent calculations.
	</p>
	
	<p>
	As you can see, the code snippet above defines a simple Euclidean geometric algebra
	generated by a 3-dimensional vector space.  The following example generates a Minkowski
	geometric algebra generated by a 5-dimensional vector space.
	</p>
	
<pre>
  galua_api.def_basis{ "e1", "e2", "e3", "no", "ni" }
  galua_api.def_sig( function( i, j )
    local ip_table =
    {
      { +1,  0,  0,  0,  0 },
      {  0, +1,  0,  0,  0 },
      {  0,  0, +1,  0,  0 },
      {  0,  0,  0,  0, -1 },
      {  0,  0,  0, -1,  0 },
    }
    return ip_table[i][j]
  end )</pre>
    
	<p>
	As of this writing, there is no way to define the inner product to be used by
	the underlying GA calculation engine.  The inner product that is used by GALua
	is an overloaded operator that implements the left contraction,
	right contraction, and the traditional vector-based inner product generalized to the taking of that product
	between any two blades of the same grade.
	</p>
		
	</body>
</html>