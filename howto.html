<!DOCTYPE html>
<html>
	<head>
	<title>How to use the GALua module</title>
	</head>
	<body>
	
	<h1>How to use the GALua module</h1>
	
	<p>
	The GALua module is easy to use.  There are three basic steps to using the module.
	First, you must, of course, require the module in your Lua script.  Second, define
	the geometric algebra you would like to work in.  And lastly, simply make use of the
	module functions to make the desired GA calculations.
	</p>
	
	<h3>Requiring the module</h3>
	
	<p>
	Before using the module, you have to gain access to it.  The following code snippet illustrates this.
	</p>
	
	<code>
	-- Grab the GALua API table.<br>
	local galua_api = require "galua"
	</code>
	
	<p>
	Of course, this will fail if the GALua.dll file has not been installed in a place where Lua can find it.
	It is up to you to make sure that it is installed correctly, or that you tell Lua where it can find the module.
	</p>
	
	<h3>Defining the GA</h3>
	
	<p>
	To define a geometric algebra, we give GALua a set of basis vectors and then define the behavior
	of those basis vectors in the inner product.  Such behavior is often referred to as the signature
	of the geometric algebra.
	</p>
	
	<code>
	galua_api.def_basis{ "e1", "e2", "e3" }<br>
	galua_api.def_sig( function( i, j )<br>
	&nbsp; if i == j then<br>
	&nbsp; &nbsp; return 1<br>
	&nbsp; end<br>
	&nbsp; return 0<br>
	end )<br>
	</code>
	
	<p>
	The indices given to the <code>def_sig</code> function correspond to the array
	given to the <code>def_basis</code> function.  Note than when GA calculations are
	performed the module, this function does not get called to determine the result
	of an inner product between two basis vectors.  The function given here is immediately
	evaluated to generate the full inner-product table, which is then kept and use
	internally for use in evaluating subsequent calculations.
	</p>
	
	<p>
	As you can see, the code snippet above defines a simple Euclidean geometric algebra
	generated by a 3-dimensional vector space.  The following example generates a Minkowski
	geometric algebra generated by a 5-dimensional vector space.
	</p>
	
	<code>
	galua_api.def_basis{ "e1", "e2", "e3", "no", "ni" }<br>
	galua_api.def_sig( function( i, j )<br>
	&nbsp; local ip_table =<br>
	&nbsp; {<br>
	&nbsp; &nbsp; { +1,  0,  0,  0,  0 },<br>
	&nbsp; &nbsp; {  0, +1,  0,  0,  0 },<br>
	&nbsp; &nbsp; {  0,  0, +1,  0,  0 },<br>
	&nbsp; &nbsp; {  0,  0,  0,  0, -1 },<br>
	&nbsp; &nbsp; {  0,  0,  0, -1,  0 },<br>
	&nbsp; }<br>
	&nbsp; return ip_table[i][j]<br>
	end )<br>
	</code>
    
	<p>
	As of this writing, there is no way to define the inner product to be used by
	the underlying GA calculation engine.  The inner product that is used by GALua
	is an overloaded operator that implements the left contraction,
	right contraction, and the traditional vector-based inner product generalized to the taking of that product
	between any two blades of the same grade.
	</p>
	
	<h3>Making GA calculations</h3>
	
	<p>
	Now that our GA is defined, we're ready to start making use of the new
	multi-vector data-type available in Lua.
	One way to get started is to simply grab a multi-vector data-type for each
	basis vector you define earlier.
	</p>
	
	<code>
	local e1 = galua_api( "e1" )<br>
	local e2 = galua_api( "e3" )<br>
	local e3 = galua_api( "e3" )<br>
	</code>
	
	<p>
	Using these, we can formulate vectors, and then use vector to formulate blades and so on and so forth.
	</p>
	
	<code>
	local vecA = -2*e1 + e2<br>
	local vecB = e2 - 4*e3<br>
	local bivecA = vecA ^ -vecB - e2^e3<br>
	local bivecB = vecA ^ 2*e2<br>
	local tivecA = vecA ^ vecB ^ e3<br>
	</code>
	
	<p>
	As you can see, a number of operators have been overloaded to work with the new multi-vector data-type.
	The asterisk and carrot operators provide the geometric and outer products, respectively.
	When a scalar is involved in any one of these products, as well as the inner product, these
	products reduce to the scalar-blade product.  Operator precedence is defined by Lua.
	The modulus operator provides the inner product.
	</p>
	
	<code>
	local scalar = vecA % vecB<br>
	local vecC = bivecA % vecB<br>
	</code>
	
	<p>
	You can also use the brackets operator.  This may make the code more readable
	if you prefer to use the left and right contraction operators; although, of course,
	Lua will only syntactically allow the bracket operator to appear on the right side
	of a variable.
	</p>
	
	<code>
	scalar = vecA[ vecB ]<br>
	vecC = bivecA[ vecB ]<br>
	</code>
	
	<p>
	At the time of this writing, an attempt has been made to overload Lua's dot
	operator as the inner product.
	</p>
	
	<code>
	scalar = vecA . vecB
	</code>
	
	<p>
	To make this work, the GALua module has to synthesize Lua's native scoping algorithm,
	which it can only do through the use of the debug library.  It is not currently
	recommended that you make use of this feature.
	</p>
	
	<p>
	To print a multi-vector, simply use the built-in <code>tostring</code> function.
	</p>
	
	<code>
	print( "vecC = " .. tostring( vecC ) )<br>
	print( "trivecA = " .. tostring( trivecA ) )<br>
	</code>
	
	<p>
	The GALua module overloads a few more Lua operators to provide some convenient features.
	For example, you can use the pound character to find the magnitude of a multi-vector.
	</p>
	
	<code>
	local magTrivecA = #trivecA<br>
	print( "|" .. tostring( trivecA ) .. "| = " .. tostring( magTrivecA ) )<br>
	</code>
	
	<p>
	The indexing operator (brackets operator) has been overloaded to allow you to set and get
	parts of a multi-vector that are homogeneous of the given grade.
	</p>
	
	<code>
	local multiVec = scalar + vecC + bivecA + trivecA + bivecB*vecA<br>
	local scalarPart = multiVec[0]<br>
	local vectorPart = multiVec[1]<br>
	local bivecPart = multiVec[2]<br>
	multiVec[1] = vecB<br>
	multiVec[3] = -7*e1^e2^e3<br>
	</code>
	
	<p>
	Two functions to be aware of are the <code>inverse</code> and <code>reverse</code> functions.
	Note that the inverse function will return zero if given a singular multi-vector.
	</p>
	
	<code>
	local vecAInv = inverse( vecA )<br>
	local bivecAInv = inverse( bivecB )<br>
	local multiVecRev = reverse( multiVec )<br>
	</code>
	
	<p>
	Of course, the geometric product is not generally commutative, so it is not immediately clear whether
	a multi-vector, if non-singular, commutes with its inverse.  The type of inverse calculated
	by default is the multi-vector that, if multiplied in the geometric product on the right of the inverted
	multi-vector, will give you the multiplicative identity with respect to the geometric product.
	</p>
	
	<p>
	Lastly, we should note that when you assign one multi-vector to another,
	you are not making a copy of the multi-vector.  Instead, you are creating
	two variables that reference the same multi-vector.  Consequently, the
	following code removes the grade zero part of the value referenced by
	both variables.
	</p>
	
	<code>
	local multiVecA = 7 + 2*e2 + e1^e2<br>
	local multiVecB = multiVecA<br>
	multiVecB[0] = 0<br>
	</code>
	
	<p>
	What the programmer may have intended to write is the following.
	</p>
	
	<code>
	local multiVecA = 7 + 2*e2 + e1^e2<br>
	local multiVecB = multiVecA:copy()<br>
	multiVecB[0] = 0<br>
	</code>
	
	<p>
	Here we're making use of the <code>copy</code> user-data method supported
	by the multi-vector data-type.  This method creates and returns a copy
	of the multi-vector.  The two variables then each reference their own
	copy of the multi-vector so that only one variable's value is affected.
	</p>
	
	<p>
	For now, that's basically it.  There is actually an internal language
	implemented by the GALua module, which is accessed by the overload to
	the function-call syntax on the <code>galua</code> table.  We used it
	to simply get at the basis vectors, but you can actually do math with it as well.
	</p>
	
	<code>
	multiVec = galua( "3*e1 + 4*e1 - 5*e1^e2 + e1.e1 + (e1^e2)*e3" )<br>
	</code>
	
	<p>
	This internal language has a number of its own features, but they're not worth going into,
	and they're beside the point of the module.
	The point of the module is that of leveraging the power of a version of Lua endowed
	with a the multi-vector data-type.  The current implementation of the underlying GA calculation
	engine is admittedly slow, but it works.
	</p>
	
	</body>
</html>
