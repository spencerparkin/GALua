---
layout: common_layout
---
<section class="content">
	
<h1>Utilizing the CGA companion module</h1>

<h2>Introduction</h2>

<p>The CGA companion module comes along with and is dependent upon the GALua module.
It provides a number of Lua classes, each representative of a geometric primitive of
the conformal geometric algebra (CGA) for 3-dimensional space.
These geometries are listed in the following table, each accompanied with a loose description.</p>

<table border="1">
<tr><td>Geometry</td><td>Description</td></tr>
<tr><td>Point</td><td>The basic element making up all geometries.</td></tr>
<tr><td>Sphere</td><td>A set of all points equidistance to a given point.</td></tr>
<tr><td>Plane</td><td>A set of coplanar points.</td></tr>
<tr><td>Line</td><td>A set of colinear points.</td></tr>
<tr><td>Point-Pair</td><td>A set of colinear points equidistant to a given point.</td></tr>
<tr><td>Circle</td><td>A set of coplanar points equidistant to a given point.</td></tr>
<tr><td>Flat-Point</td><td>Another point representation of CGA.</td></tr>
</table>

<p>
The flat-point has some interesting properties in CGA, one of which is that it is
the only geometry of CGA that, when expressed in direct form, cannot be written
as the outer product of (round) points.
In any case case, this page is not an attempt to teach CGA.  For that, I refer the
reader to the following list of sources.
</p>

<ul>
<li>What may have been the <a href="http://geocalc.clas.asu.edu/pdf-preAdobe8/OldWine.pdf">original white paper</a> on CGA.</li>
<li>This <a href="http://www.geometricalgebra.net/">book</a> covers CGA in great detail, although I feel it lacks a great deal of rigour.  Be sure to consult the errata page.</li>
<li>A short <a href="http://www.gaalop.de/dhilden_data/CLUScripts/CandG_PrePrint.pdf">tutorial</a> on CGA.</li>
</ul>

<p>
An instance of one of the classes of the CGAUtil module is an object representative of
a CGA geometry.  Being a Lua table, it's entries give the defining characteristics
of that geometry.  As we know from CGA, however, it is the blades of the Minkownski
geometric algebra that are either dually or directly representative of a given piece
of geometry.  (On the other hand, a given blade simultaneously represents two
different geometries: one dually, the other directly.  Which we care about is simply
a matter of interpretation -- a choice we are free to make.)  Where the use of the
CGAUtil module comes into play, therefore, is in its ability to convert between such
blades and objects (class instances).  The conversion from object to blade is known
as composition, while the conversion from blade to object is known as decomposition.
</p>

<p>
To free this tutorial from the great many mathematical details chosen by the CGAUtil module,
such details are given at length in the following document, which has been prepared
specifically for the CGAUtil module and its documentation.
</p>

<p><a href="CGAUtilMath.pdf">CGAUtilMath.pdf</a></p>

<p>
A great deal of thought and effort has gone into making sure that this math is correct.
Any update to the math performed in the CGAUtil module will also be reflected in a
change to this document.
</p>

<p>
All of this said, we're now ready to show how one may go about using the CGAUtil module.
We will do so by simply giving a number of examples that illustrate the usage of
various features of the module.
</p>

<h2>Example 1: Fitting a circle to 3 points</h2>

<p>We start by simply created 3 points that determine a circle.  To determine a circle,
they must be non-colinear.</p>

<pre class="example">
local point1 = cga.NewPoint{ center = cga.evec( -1, 0, 0 ) }:ComposeBlade()
local point2 = cga.NewPoint{ center = cga.evec( 1, 0, 0 ) }:ComposeBlade()
local point3 = cga.NewPoint{ center = cga.evec( 0, 1, 0 ) }:ComposeBlade()
</pre>

<p>
This code illustrates a number of features.  First, notice the <code>cga.evec(...)</code> function.
This is a convenience function provided by CGAUtil that allows you to easily formulate euclidean
vectors.  It is simply implemented as follows.
</p>

<pre class="example">
function CGAUtil.evec( x, y, z )
  return x*e1 + y*e2 + z*e3
end
</pre>

<p>
Secondly, notice the <code>cga.NewPoint(...)</code> function.  This function creates and
returns an object representative of a conformal point.  Such a function is provided
for all the conformal geometries.  The entire list is given in the following table.
</p>

<table>
<tr><td>Creation function</td></tr>
<tr><td><code>cga.NewPoint(...)</td></tr>
<tr><td><code>cga.NewSphere(...)</td></tr>
<tr><td><code>cga.NewCircle(...)</td></tr>
<tr><td><code>cga.NewPlane(...)</td></tr>
<tr><td><code>cga.NewPointPair(...)</td></tr>
<tr><td><code>cga.NewLine(...)</td></tr>
<tr><td><code>cga.NewFlatPoint(...)</td></tr>
</table>

<p>
Tangent points and free blades will be discussed later on.
</p>

<p>Unlike a consideration we would have concerning a given blade, for
any object returned by one of these creation routines,
we never care about how that object represents its geometry.  For example,
an object does not dually or directly represent a CGA geometry.  This brings up
what may be a confusing point in the semantics of CGA.  Geometrically speaking,
there is no difference, for example, between a dual sphere and a direct sphere.
A sphere is just a sphere.  Those terms arrise, however, in an attempt to be
more specific about <i>how</i> a given blade represents a certain geometry,
but despite the difference in names, it has no bearing on the actual physical geometry to
which we are referring.</p>

<p>
To be more precise, given any CGA geometry, there exist two blades representative
of that geometry: one does so dually, the other directly, and it's not hard to show
that these are simply duals of one another.
Given any blade, we can choose a dual or direct interpretation of it; and often
it is to our advantage to pick between the two the geometry most applicable to the
problem we are trying to solve.  (You'll see an example of this in the next example.)
</p>

<p>
Returning to the example at hand, notice that we handed a table to the
<code>cga.NewPoint(...)</code> function.  This table is expected to
contain zero or more of the following entries, not all of which are
applicable to conformal points, but may be applicable to other CGA geometries.
We give the full list here for completeness.
</p>

<table>
<tr><td>Table Entry Key</td><td>Table Entry Value Description</td><td>Default Value</td></tr>
<tr><td>"<code>weight</code>"</td><td>A non-zero scalar value.</td><td>One</td></tr>
<tr><td>"<code>center</code>"</td><td>A euclidean location vector.</td><td>Zero</td></tr>
<tr><td>"<code>normal</code>"</td><td>A unit-length euclidean direction vector.</td><td>e1</td></tr>
<tr><td>"<code>radius</code>"</td><td>A non-negative scalar value.</td><td>One</td></tr>
<tr><td>"<code>imaginary</code>"</td><td>A boolean value.</td><td>False</td></tr>
</table>

<p>
If any one of these table entries is missing, a default will be used.  The default
values are also listed in the above table.
</p>

<p>
Thirdly and lastly, notice the "<code>:ComposeBlade()</code> method call.  Supported by
all geometry objects of CGAUtil, this function formulates a blade, (as a function of the defining characteristics
of its geometry being represented by the object), that is dually representative of that geometry.
To get the direct representation of the geometry, simply take the dual of the returned result.
</p>

<p>Having created our 3 points, we can easily find the circle fitting these points as follows.</p>

<pre class="example">
local dirCircle = point1 ^ point2 ^ point3
local dualCircle = dirCircle * cga.I
local circleObj = cga.NewCircle( dualCircle )
</pre>

<p>Here we see that instead of passing a table to the creation function, we have
passed in a blade dually representative of the computed circle.  Doing this, the
constructor of the object will attempt to decompose the given blade.  Nil is returned
if the decomposition fails.  All composition functions create a dual geometry as output and all
decomposition functions expect a dual geometry as input.</p>

<p>You'll also notice the <code>cga.I</code> constant.  This is defined as the unit pseudo-scalar
of our Minkownski geometric algebra.  CGAUtil also defines <code>cga.i</code> as the unit pseudo-scalar
of the largest Euclidean geometric sub-algebra of our Minkowski geometric algebra.  To be precise about
the sign of these pseudo-scalars, they are defined internally as follows.</p>
	
<pre class="example">
no_ni = no ^ ni
i = e1 ^ e2 ^ e3
I = i ^ no_ni
</pre>
	
<p>Having now created <code>circleObj</code>, we are free to inspect its table entries
to learn about the circle fitting the 3 points.</p>
	
<pre class="example">
for key, value in pairs( circleObj ) do
  print( key .. ": " .. tostring( value ) )
end
</pre>

<p>Running the entire example, you should get the following, listed in perhaps some other order, of course.</p>
	
<pre class="example">
weight: 2
radius: 1
normal: -e3
imaginary: false
center: 0
type: circle
</pre>

<p>If given any object instance, and you are not sure what type of object it may be, you may always
check the <code>type</code> entry of the object table to find out what type of object it is.

<h2>Example 2: The point-sphere silhouette problem</h2>

<p>
Given a sphere and a point some distance from the sphere, imagine viewing
the sphere from this distant point.  Imagine a circle that outlines the
sphere from this perspective.  Now, if this circle shared every point with
the sphere, what circle would it be?  This is the problem we want to solve,
and we'll do it with CGAUtil.
</p>

<p>Do that here...</p>

<h2>Example 3: The inversion of a line in a sphere</h2>

<h2>Conclusion</h2>
	
</section>